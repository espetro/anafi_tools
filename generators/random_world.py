# -*- coding: utf-8 -*-

from __future__ import print_function
from itertools import product, starmap
from random import randint
# product is essentially combinations without repetitions
# starmap is an iterator that applies a function over a set of tuples (generated by product)

import pickle as pk
import numpy as np
import os

class RandomWorld:

    def __init__(self, shape, sub2goal_dist, no_peds, obj_probs, max_objs):
        """"""
        self.shape = shape
        self.grid = np.zeros(shape, dtype=str)

        self.subj_pos, self.goal_pos = (0,0), (0,0)
        self.no_peds = no_peds
        self.max_objs = max_objs
        self.probs = obj_probs

        self._place_goal(sub2goal_dist)
        self._place_drone(1)
        self._place_peds(no_peds)
        self._place_objs(max_objs)

    @staticmethod
    def mhd(tileA, tileB):
        """Computes the Manhattan distance between two (x,y) tiles"""
        return abs(tileA[0] - tileB[0]) + abs(tileA[1] - tileB[1])

    def _place_goal(self, min_dist=5):
        """Places the Goal and Subject tile in a grid so that they are at a minimum distance"""
        max_x, max_y = [p - 1 for p in self.shape]
        
        while RandomWorld.mhd(self.subj_pos, self.goal_pos) < min_dist:
            self.subj_pos = (randint(0, max_x), randint(0, max_y))
            self.goal_pos = (randint(0, max_x), randint(0, max_y))
            
        self.grid[self.subj_pos] = "S"
        self.grid[self.goal_pos] = "G"

    @staticmethod
    def neighbors(shape, pos, rad=1):
        """Gets the set of surrounding tiles given a tile and its set radius"""
        max_X, max_Y = shape
        
        jumps = [0] + [-x for x in range(1, rad+1)] + [x for x in range(1, rad+1)]
        area = list(starmap(lambda a,b: (pos[0] + a, pos[1] + b), product(jumps, jumps)))
        
        return [p for p in area[1:] if (p[0] in range(max_X) and p[1] in range(max_Y))]

    def _place_drone(self, dist=1):
        """Places the drone at a certain distance from the subject"""
        block = RandomWorld.neighbors(self.shape, self.subj_pos, dist)
        self.drone_pos = block[randint(0, len(block) - 1)]
        self.grid[self.drone_pos] = "D"

    @staticmethod
    def grid_range(init_pos, end_pos):
        """
        Computes the range of the pedestrian path or wall width.
        :param init_pos:
        :param end_pos:
        :returns: A tuple (line, (init_x, init_y), (end_x, end_y)) where 'line'
                is a tuple (X, -1) or (-1, X) being 'X' the common coordinate
        """
        if init_pos[0] == end_pos[0]:
            # line'd be a row
            line, init, end = init_pos[0], init_pos[1], end_pos[1]
        elif init_pos[1] == end_pos[1]:
            # line'd be a col
            line, init, end = init_pos[1], init_pos[0], end_pos[0]
        return (line, init, end)

    @staticmethod
    def grp_range(group, common_y):
        """"""
        is_y, idx = common_y
        if is_y:
            idx_x = [x for (x,_) in group]
            idx_y = idx
        else:
            idx_x = idx
            idx_y = [y for (_,y) in group]
            
        return (idx_x, idx_y)

    @staticmethod
    def group_by_adj(ls, min_length=2, max_length=1000, common_y=False):
        """Groups elements whose two-by-two distance is 1, i.e. are adjacent."""
        
        if type(ls) is not list or len(ls) == 0:
            return []
        
        groups = []
        curr_group = [ls[0]]
        xs = ls[1:]
        
        while len(xs) > 0:
            d = RandomWorld.mhd(curr_group[-1], xs[0])
            # print("dist({}, {}) is {}".format(curr_group[-1], xs[0], d))
            
            if d == 1:
                # If the next node is adjacent, add it to the group
                curr_group.append(xs[0])
                # print("Current expanded to {}".format(curr_group))
            else:
                # Otherwise, close the current group and create a new one
                idx_x, idx_y = RandomWorld.grp_range(curr_group, common_y)
                groups.append((curr_group, idx_x, idx_y))
                # print("New group added: {}".format(groups))
                curr_group = [xs[0]]
            xs = xs[1:]
            
        # return [g for g in groups if len(g) >= min_length and len(g) <= max_length]
        idx_x, idx_y = RandomWorld.grp_range(curr_group, common_y)
        groups.append((curr_group, idx_x, idx_y))
        return [(g,x,y) for (g,x,y) in groups if len(g) in range(min_length, max_length)]

    @staticmethod
    def choose_path(empties, shape, min_length=2):
        """
        Returns a path tuple whose length is at maximum, max_length.
        :returns: A tuple (line, init, end)
        """
        paths = []
        max_length = max(*shape)
        
        # Rows
        for rn in range(shape[0]):
            curr_row_groups = RandomWorld.group_by_adj([(x,y) for (x,y) in empties if x == rn], min_length, max_length, common_y=(False, rn))
            paths += curr_row_groups
            
        # Columns
        for cn in range(shape[1]):
            curr_col_groups = RandomWorld.group_by_adj([(x,y) for (x,y) in empties if y == cn], min_length, max_length, common_y=(True, cn))
            paths += curr_col_groups
            
        rnd = paths[randint(0, len(paths) - 1)]
        # print(rnd)
        return rnd
        
    def _place_peds(self, no_peds):
        """
        Place a limited number of pedestrians in the grid. Subject, Drone and Goal poses cannot
        be overwritten by the pedestrians
        """
        empties = np.argwhere(self.grid == '')
        
        self.peds = dict()
        for p in range(no_peds):
            nm = "P{}".format(p)
            self.peds[nm] = {}
            self.peds[nm]["pos"] = (line, pX, pY) = RandomWorld.choose_path(empties, self.shape)
            self.peds[nm]["loop"] = bool(randint(0,1))
            
            # Writes "o" in the points between
            # print(pX, pY)
            
            self.grid[pX, pY] = "o"
            # Writes "PX" in the init and start of the ped path
            self.grid[line[0]] = self.grid[line[-1]] = nm

    def _place_objs(self, max_objs):
        """
        Place a limited number of objects, depending on the probabilities of each object type.
        :param grid:
        :param probs: A dictionary holding probabilities for Trees,Walls,Doors
        :param max_objs:
        """
        
        self.trees, self.doors, self.walls = dict(), dict(), dict()
        tree_rng = int(max_objs * self.probs["tree"])
        door_rng = int(max_objs * self.probs["door"])
        wall_rng = int(max_objs * self.probs["wall"])
        
        for tn in range(tree_rng):
            empties = np.argwhere(self.grid == '')
            nm = "T{}".format(tn)
            # places the tree in an empty cell
            self.trees[nm] = dict(
                pos = empties[randint(0, len(empties) - 1)]
            )
            pX, pY = self.trees[nm]["pos"]
            self.grid[pX, pY] = "T"
            
        for dn in range(door_rng):
            empties = np.argwhere(self.grid == '')
            nm = "D{}".format(dn)
            # places the door in an empty cell with a random direction (only two: North/South and West/East)
            self.doors[nm] = dict(
                pos = empties[randint(0, len(empties) - 1)],
                ori = ["N", "W"][randint(0,1)]
            )
            pX, pY = self.doors[nm]["pos"]
            self.grid[pX, pY] = "D"
            
        for wn in range(wall_rng):
            empties = np.argwhere(self.grid == '')
            nm = "W{}".format(wn)
            self.walls[nm] = dict(
                pos = RandomWorld.choose_path(empties, self.shape) # returns (init:line:end)
            )
            # Writes "W" in the whole wall path
            _, pX, pY = self.walls[nm]["pos"]
            self.grid[pX, pY] = "W"

    def load_from(self, fpath):
        """Loads a serialized grid configuration"""
        with open(fpath, "rb") as f:
            world_conf = pk.load(f)
            (
                self.grid, self.goal_pos, self.subj_pos,
                self.drone_pos, self.peds, self.trees,
                self.doors, self.walls
            ) = world_conf

        return self

    def save_to(self, fpath):
        """Saves the current grid configuration to a serialized file."""
        with open(fpath, "wb") as f:
            world_conf = (
                self.grid, self.goal_pos, self.subj_pos,
                self.drone_pos, self.peds, self.trees,
                self.doors, self.walls
            )
            pk.dump(world_conf, f)


if __name__ == "__main__":
    obj_probs = obj_probs = {"tree": 0.4, "door": 0.0, "wall": 0.2}

    world = RandomWorld(
        shape=(5,5),
        sub2goal_dist=4,
        no_peds=1,
        obj_probs=obj_probs,
        max_objs=5
    )
    print(world.grid)

    # world.save_to("example_grid.pk")